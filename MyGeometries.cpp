//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "MyPendulum.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"
#include <random>

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;
phMaterial materialUnderTextureBright;
phMaterial materialUnderTextureDark;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 12;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "gothwall.bmp",
    "arabesque.bmp",
    "barrel.bmp",
    "vangogh.bmp",
    "catto2.bmp",
    "soccerball.bmp",
    "rug.bmp",
    "newton.bmp",
    "torch.bmp",
    "wildejagd.bmp",
    "rope.bmp",
    "apple3.bmp"
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.75);   


// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 9;

enum {
    iFloor,
    iCircularSurf,
    iWall,
    iLwall,
    iLines,
    iNewton,
    ilTorch,
    irTorch,
    iPaint
};

/*
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2; // RESERVED FOR USE BY 155A PROJECT
const int iLines = 3;
const int iNewton = 4;
const int ilTorch = 5;
const int irTorch = 6;
*/

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)
int frame = 0;
float x_1, y_1, x_2, y_2;
double weight1 = 1.05;
double weight2 = 0.85;




// changes this to edit step size / animation length
// dt = 0.016 to get fps ~= 60.
// animation runs for 120 seconds. pen_vals eats up roughly 30Kb, but calculation takes a good amount of time.
// This is because we are using RK4 method (which calculates slope from 4 data points each step).
// There are likely roundoff errors.
const int num_frames = (const int) (120.0 / 0.016);

// array to store info of pendulum
double pen_vals[num_frames * 4];

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.75, 0.75, 0.75);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 43.0;

    materialUnderTextureBright.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTextureBright.AmbientColor.Set(0.35, 0.35, 0.35);
    materialUnderTextureBright.DiffuseColor.Set(0.85, 0.85, 0.85);       // Increase or decrease to adjust brightness
    materialUnderTextureBright.SpecularExponent = 40.0;


    materialUnderTextureDark.SpecularColor.Set(0.45, 0.45, 0.45);
    materialUnderTextureDark.AmbientColor.Set(0.2, 0.2, 0.2);
    materialUnderTextureDark.DiffuseColor.Set(0.4, 0.4, 0.4);
    materialUnderTextureDark.SpecularExponent = 40.0;
    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         5.0f, 0.0f,  5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -5.0f, 0.0f,  5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);


  


    float wallVerts[]{
        -5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
         5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
         5.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
        -5.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left

    };
    unsigned int wallElts[] = { 0, 1, 3, 2 };
    
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts), wallElts, GL_STATIC_DRAW);

    
    float lwallVerts[]{
         -5.0f, 0.0f, 5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
         -5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
         -5.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
         -5.0f, 5.0f, 5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left

    };
    unsigned int lwallElts[] = { 0, 1, 3, 2 };

    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iLwall]);
    glBindVertexArray(myVAO[iLwall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(lwallVerts), lwallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iLwall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(lwallElts), lwallElts, GL_STATIC_DRAW);


    float newtonVerts[]{
        -1.5f, 1.5f, -4.95f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Bottom left
         1.5f, 1.5f, -4.95f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Bottom right
         1.5f, 3.5f, -4.95f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Top right
        -1.5f, 3.5f, -4.95f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Top left

    };
    unsigned int newtonElts[] = { 0, 1, 3, 2 };

    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iNewton]);
    glBindVertexArray(myVAO[iNewton]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(newtonVerts), newtonVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iNewton]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(newtonElts), newtonElts, GL_STATIC_DRAW);



    float ltorchVerts[]{
        -3.5f, 2.2f, -4.95f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
        -3.0f, 2.2f, -4.95f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
        -3.0f, 4.2f, -4.95f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
        -3.5f, 4.2f, -4.95f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left
    };

    unsigned int lTorchelts[] = { 0, 1, 3, 2 };

    glBindBuffer(GL_ARRAY_BUFFER, myVBO[ilTorch]);
    glBindVertexArray(myVAO[ilTorch]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(ltorchVerts), ltorchVerts , GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[ilTorch]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(lTorchelts), lTorchelts, GL_STATIC_DRAW);


    float paintVerts[]{
        -4.95f, 1.0f, 3.5f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
        -4.95f, 1.0f, -3.5f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
        -4.95f, 4.0f, -3.5f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
        -4.95f, 4.0f, 3.5f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left
    };
    unsigned int paintElts[] = { 0, 1, 3, 2 };

    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iPaint]);
    glBindVertexArray(myVAO[iPaint]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(paintVerts), paintVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iPaint]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(paintElts), paintElts, GL_STATIC_DRAW);

    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    SamsRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes );

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************



/*
* Get coordinates of the pendulum stuffs here.
* 
*/
void mySetupPendulum() {

    std::default_random_engine generator;
    std::uniform_real_distribution<double> distribution1(PIthirds, PIhalves);
    std::uniform_real_distribution<double> distribution2(PIhalves, PIhalves + PIfourths);
    std::uniform_real_distribution<double> distribution3(70.0, 90.0);



    // both pendulums start at theta1, theta 2, which are randomly generated from range PIthirds :: PIhalves, and PIhalves :: 3/4 PI.
    // Initial angular momentum = 0.
    // upper pend: initial spring len 1.0m, weight 1.05kg
    // lower pend: initial spring len 0.95m, weight 0.85kg
    // Spring constant k_1 and k_2 are randomly generated from 70.0 to 90.0.
    Pendulum upperPendulum(distribution1(generator), 0, 0.0, 1.0, weight1, 1.0, distribution3(generator));
    Pendulum lowerPendulum(distribution2(generator), 0, 0.0, 0.95, weight2, 0.95, distribution3(generator));

    // Create MyPendulum (double spring pendulum) object.
    MyPendulum mp(upperPendulum, lowerPendulum);
    for (int i = 0; i < num_frames; i++) {
        // update() changes values like theta1 / r1 of the mp object by running Runge-Kutta by 1 step.

        mp.update();

        // save these values into pen_vals vector.
        pen_vals[4 * i] = (float) mp.theta1();
        pen_vals[4 * i + 1] = (float) mp.r1();
        pen_vals[4 * i + 2] = (float) mp.theta2();
        pen_vals[4 * i + 3] = (float) mp.r2();
    }
}

void myRenderPendulum() {
    float matEntries[16];


    // update frame
    if (frame <= num_frames && spinMode) {
        x_1 = pen_vals[4 * frame + 1] * sin(pen_vals[4 * frame]);
        y_1 = -pen_vals[4 * frame + 1] * cos(pen_vals[4 * frame]);

        x_2 = x_1 + pen_vals[4 * frame + 3] * sin(pen_vals[4 * frame + 2]);
        y_2 = y_1 - pen_vals[4 * frame + 3] * cos(pen_vals[4 * frame + 2]);
        frame += 1;
    }
   
    // Render ball 1
    // Frame is incremented above, so subtract 1 to get the correct frame
    float theta1 = pen_vals[4 * (frame-1)];
    float r1 = pen_vals[4 * (frame-1)+1];
    float theta2 = pen_vals[4 * (frame-1)+2];
    float r2 = pen_vals[4 * (frame-1)+3];
   
    LinearMapR4 matDemo = viewMatrix;
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate( x_1, (y_1)+4.0, 0.0);
    matDemo.Mult_glScale(0.2 * weight1);
  
    LinearMapR4 pos1 = matDemo;
    
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texSphere.Render();

    
    // Render spring 1
    
    LinearMapR4 matDemo2 = viewMatrix;
   
    

    // move center of spring to lerp(0, x_1, 1/2) and lerp (0, y_1, 1/2)
    matDemo2.Mult_glTranslate(x_1 / 2, 2.0 + ((4.0 + y_1) / 2), 0.0);
    // rotate spring by theta 1
    
    matDemo2.Mult_glRotate(theta1, 0.0, 0.0, 1.0);

    // scale vertical length of spring by r1/2, because the original height of the spring is 2.
    matDemo2.Mult_glScale(0.05, r1/2, 0.05);
    materialUnderTexture.LoadIntoShaders();
    matDemo2.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);
    glUniform1i(applyTextureLocation, true);
    texCylinder.RenderBase();
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();
    // Render ball 2

    LinearMapR4 matDemo3 = viewMatrix;

    matDemo3.Mult_glTranslate( x_2, (y_2)+4.0, 0);
    matDemo3.Mult_glScale(0.2 * weight2);
   
    matDemo3.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texSphere.Render();
    // Render spring 2
   
    LinearMapR4 matDemo4 = viewMatrix;

    matDemo4.Mult_glTranslate((x_1 + x_2)/2, 4.0 + (y_1+y_2)/2, 0);
    matDemo4.Mult_glRotate(theta2, 0.0, 0.0, 1.0);
    matDemo4.Mult_glScale(0.05, r2/2, 0.05);
    materialUnderTexture.LoadIntoShaders();
    matDemo4.DumpByColumns(matEntries);
    
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);

    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);
    glUniform1i(applyTextureLocation, true);
    texCylinder.RenderBase();
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();
    

}
void MyRenderGeometries() {

    float matEntries[16];       // Temporary storage for floats
    // ******
    // Render the Floor - using a procedural texture map
    // ******
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTextureDark.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);    
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // **************
    // Render the circular surface

    //selectShaderProgram(shaderProgramBitmap);
    //SamsRenderCircularSurf();

    // ************ 
    // Render the back wall
    //  YOU MUST WRITE THIS. IT WILL BE SIMILAR TO THE FLOOR ABOVE. 
    //  BUT USE A BITMAP (shaderProgramBitmap) INSTEAD OF A PROCEDURAL TEXTURE.

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    // Rod attached to pendulum
    LinearMapR4 matDemo = viewMatrix;

    matDemo.Mult_glTranslate(0.0, 4, -2.4);
    matDemo.Mult_glRotate(PIhalves, 1.0, 0.0, 0.0);
    matDemo.Mult_glScale(0.13, 2.5, 0.13);
    
    materialUnderTexture.LoadIntoShaders();
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);

    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);
    glUniform1i(applyTextureLocation, true);
    texCylinder.RenderBase();
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();



    // Left wall

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iLwall]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    // Newton image
    glPolygonOffset(0.75, 0.1);
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iNewton]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    // Left torch
    glPolygonOffset(0.75, 0.1);
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[ilTorch]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTextureDark.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    // painting
    glPolygonOffset(0.75, 0.1);
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iPaint]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTextureBright.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    // apple
    matDemo = viewMatrix;

    matDemo.Mult_glTranslate(3.5, 2.4, -4.0);
    //matDemo.Mult_glRotate(PIhalves, 1.0, 0.0, 0.0);
    matDemo.Mult_glScale(0.3);

    materialUnderTexture.LoadIntoShaders();
    matDemo.DumpByColumns(matEntries);

    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);

    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);
    glUniform1i(applyTextureLocation, true);
    texSphere.Render();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();
    // 
    // 
    // 
    // *************
    // Render two spheres and a cylinder
    // YOU MUST MODIFY THE CODE BELOW, AND ADD TEXTURES TO THE SPHERE AND THE CAPS OF THE CYLINDER.

    // Render a sphere with a earth image texture map
    //  YOU DO NOT NEED TO MODIFY THIS SPHERE OR ITS TEXTURE MAP

    /*
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-3.5, 1.1, 0.4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    // Render a sphere with a texture map 
    // ADD A TEXTURE MAP TO THIS SPHERE - SIMILAR TO THE CODE ABOVE
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate( 3.5, 1.1, 0.4);
    matDemo.Mult_glRotate(PI / 2.0, 0.0, 1.0, 0.0);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);
    texSphere.Render();              
    glUniform1i(applyTextureLocation, false);// Render the sphere

    */

    myRenderPendulum();

    // Render a cylinder 
    // YOU MAY LEAVE THE TEXTURE MAP ON THE SIDE OF THE CYLINDER
    // YOU MUST ADD TEXTURE MAPS TO THE TOP AND BOTTOM FACES OF THE CYLINDER
    // NOTE THERE ARE SEPARATE RENDER COMMANDS FOR THE THREE PARTS OF THE CYLINDER.
    // YOU WILL ALSO CHANGE THE ORIENTATION OF THE CYLINDER
    matDemo = viewMatrix;
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(3.5, 1.1, -4.0);
    matDemo.Mult_glRotate(PI / 2.0, 0.0, 0.0, 1.0);
    materialUnderTextureDark.LoadIntoShaders();
    matDemo.DumpByColumns(matEntries);       
         // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose texture 
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);    // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);
    texCylinder.RenderTop();                
    glUniform1i(applyTextureLocation, false); 
    // RENDER THIS WITH A TEXTURE MAP
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);
    texCylinder.RenderBase();     
    glUniform1i(applyTextureLocation, false); // RENDER THIS WITH A TEXTURE MAP

    
    // Renders a textured torus in the back left corner.
    // matDemo = viewMatrix;
    // matDemo.Mult_glTranslate(-4.0, 0.3, -3.0);
    // matDemo.Mult_glScale(0.8, 0.2, 0.8);
    // matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    // glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    // glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose texture
    // glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
    // texTorus.Render();                                  // Render the torus
    // glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
        
    check_for_opengl_errors();      // Watch the console window for error messages!
}

void SamsRenderCircularSurf()
{
    float matEntries[16];       // Temporary storage for floats

    glBindVertexArray(myVAO[iCircularSurf]);

    // Calculate the model view matrix for the circular surface
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 0.8, -2.5);     // Center in the back & raise up
    matDemo.Mult_glScale(0.18, 0.4, 0.18);         // Adjust the circular diameter and height

                                                 // Set the uniform values (they are not stored with the VAO and thus must be set again everytime
    materialUnderTexture.LoadIntoShaders();                       // Use the bright underlying material
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries); // Select the modelview matrix to place it
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose Mandala texture
    // ONCE YOU HAVE TEXTURE COORDINATES FOR THE CIRCULAR SURFACE, PUT THE NEXT LINE BACK IN.
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                                                                   // Draw the the triangle strips
    for (int i = 0; i < meshRes; i++) {
        glDrawElements(GL_TRIANGLE_STRIP, 1 + 2 * meshRes, GL_UNSIGNED_INT,
            (void*)(i * (1 + 2 * meshRes) * sizeof(unsigned int)));
    }
    glUniform1i(applyTextureLocation, false);           // Disable applying the texture!
}




void SamsRemeshCircularSurf()
{
    // Circular surface vertices.
    int numCircularVerts = 1 + meshRes * meshRes;
    float* circularVerts = new float[8 * numCircularVerts];
    // Circular surface elements (indices to vertices in a triangle strip)
    int numCircularElts = meshRes * (1 + 2 * meshRes);
    unsigned int* circularElements = new unsigned int[numCircularElts];

    float* toPtr = circularVerts;
    *(toPtr++) = 0.0f;      // Center point
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.0f;      // Center normal
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.5f;      // Center tex
    *(toPtr++) = 0.5f;
    for (int i = 0; i < meshRes; i++) {
        float theta = (float)PI2 * ((float)i) / (float)meshRes;
        float c = cosf(theta);
        float s = sinf(theta);
        float partialC = -s;
        float partialS = c;
        VectorR3 partialTheta(partialC, 0.0, partialS);
        for (int j = 1; j <= meshRes; j++) {
            float r = 2.9f * (float)PI * ((float)j) / (float)meshRes;
            float x = r;
            float dampingFactor = 0.08f;
            float fff = (float)(1.0 + dampingFactor * r * r);
            float y = j==0 ? 1.0f : fff*sin(r)/r;
            float xprime = 1.0;
            float yprime = (x * cosf(x) + sinf(x)) / (x + 1.0f) - x * sinf(x) / ((x + 1.0f) * (x + 1.0f));
            VectorR3 partialR((double)(c * xprime), yprime, (double)(s * xprime));
            *(toPtr++) = c * x;                 // (i,j) point
            *(toPtr++) = y;
            *(toPtr++) = s * x;
            VectorR3 normal = -partialR * partialTheta;
            normal.Normalize();
            *(toPtr++) = (float)normal.x;      // (i,j) normal
            *(toPtr++) = (float)normal.y;
            *(toPtr++) = (float)normal.z;

            *(toPtr++) = (c * x / (2.9f * PI))/3.35 + 0.5;
            *(toPtr++) = (s * x / (2.9f * PI))/3.35 + 0.5;
       }
    }

    unsigned int* toElt = circularElements;
    for (int i = 0; i < meshRes; i++) {
        *(toElt++) = 0;         // Central vertex
        for (int j = 0; j < meshRes; j++) {
            *(toElt++) = ((i + 1) % meshRes) * meshRes + j + 1;
            *(toElt++) = i * meshRes + j + 1;
        }
    }

    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBufferData(GL_ARRAY_BUFFER, 8 * numCircularVerts * sizeof(float), circularVerts, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numCircularElts * sizeof(unsigned int), circularElements, GL_STATIC_DRAW);

    delete[] circularVerts;
    delete[] circularElements;
}

